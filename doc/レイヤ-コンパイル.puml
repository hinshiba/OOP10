@startuml Compiler Layer Detail

!define INTERFACE_COLOR #C8E6C9
!define ABSTRACT_COLOR #FFE0B2

skinparam linetype ortho

' ============================================
' レイヤー間インターフェース (Facade)
' ============================================
interface ICompilerService INTERFACE_COLOR {
    + CompileAsync(source: string): Task<CompilationResult>
    + TranspileExtendedSyntax(source: string): Task<string>
    + GetAllocationInfo(): RegisterAllocationInfo
}

class CompilerService {
    - _lexer: ILexer
    - _parser: IParser
    - _allocator: IRegisterAllocator
    - _generator: ICodeGenerator
    - _assembler: IAssembler
    --
    + CompileAsync(source: string): Task<CompilationResult>
    + TranspileExtendedSyntax(source: string): Task<string>
    + GetAllocationInfo(): RegisterAllocationInfo
    --
    # ValidateSemantics(ast: AST): bool
}

ICompilerService <|.. CompilerService

' ============================================
' 字句解析 (Lexer)
' ============================================
interface ILexer INTERFACE_COLOR {
    + Tokenize(source: string): IEnumerable<Token>
    + SupportedTokenTypes: IReadOnlySet<TokenType>
}

class ExtendedLexer {
    - _tokenPatterns: Dictionary<TokenType, Regex>
    --
    + Tokenize(source: string): IEnumerable<Token>
    + SupportedTokenTypes: IReadOnlySet<TokenType>
    --
    # RecognizeVirtualRegister(text: string): Token?
    # RecognizeExtendedKeyword(text: string): Token?
}

ILexer <|.. ExtendedLexer

' ============================================
' 構文解析 (Parser)
' ============================================
interface IParser INTERFACE_COLOR {
    + Parse(tokens: IEnumerable<Token>): AST
    + ParseExpression(tokens: IEnumerable<Token>): Expression
}

abstract class BaseParser {
    # _currentToken: Token
    # _tokenEnumerator: IEnumerator<Token>
    --
    + Parse(tokens: IEnumerable<Token>): AST
    --
    # {abstract} ParseStatement(): Statement
    # Expect(type: TokenType): Token
    # Match(types: TokenType[]): bool
    # Advance(): void
}

class ExtendedParser {
    --
    + ParseExpression(tokens: IEnumerable<Token>): Expression
    --
    # ParseStatement(): Statement
    # ParseLetStatement(): LetStatement
    # ParseLoadStatement(): LoadStatement
    # ParseStoreStatement(): StoreStatement
    # ParseStandardInstruction(): Instruction
}

IParser <|.. BaseParser
BaseParser <|-- ExtendedParser

' ============================================
' レジスタ割り付け
' ============================================
interface IRegisterAllocator INTERFACE_COLOR {
    + Allocate(ast: AST, cfg: ControlFlowGraph): AllocationResult
    + BuildInterferenceGraph(liveRanges: LiveRanges): InterferenceGraph
}

class RegisterAllocator {
    - _strategy: IAllocationStrategy
    - _spillHandler: ISpillHandler
    --
    + Allocate(ast: AST, cfg: ControlFlowGraph): AllocationResult
    + BuildInterferenceGraph(liveRanges: LiveRanges): InterferenceGraph
    --
    # AnalyzeLiveness(cfg: ControlFlowGraph): LiveRanges
    # ColorGraph(graph: InterferenceGraph): Coloring
}

IRegisterAllocator <|.. RegisterAllocator

' ストラテジパターン: 割り付けアルゴリズム
interface IAllocationStrategy INTERFACE_COLOR {
    + Execute(graph: InterferenceGraph): Coloring
}

class GraphColoringStrategy {
    - _kColors: int
    --
    + Execute(graph: InterferenceGraph): Coloring
    --
    # Simplify(graph: InterferenceGraph): Stack<Node>
    # Select(stack: Stack<Node>): Coloring
}

class LinearScanStrategy {
    - _registers: PhysicalRegister[]
    --
    + Execute(graph: InterferenceGraph): Coloring
    --
    # SortByStartPoint(ranges: LiveRanges): LiveRanges
    # AllocateFreeRegister(range: LiveRange): PhysicalRegister?
}

IAllocationStrategy <|.. GraphColoringStrategy
IAllocationStrategy <|.. LinearScanStrategy

RegisterAllocator o--> IAllocationStrategy

' スピル処理
interface ISpillHandler INTERFACE_COLOR {
    + GenerateSpillCode(spillSet: ISet<VirtualRegister>): IEnumerable<Instruction>
    + AllocateStackSlots(count: int): IEnumerable<StackSlot>
}

class StackSpillHandler {
    - _stackOffset: int
    - _framePointer: PhysicalRegister
    --
    + GenerateSpillCode(spillSet: ISet<VirtualRegister>): IEnumerable<Instruction>
    + AllocateStackSlots(count: int): IEnumerable<StackSlot>
}

ISpillHandler <|.. StackSpillHandler
RegisterAllocator o--> ISpillHandler

' ============================================
' コード生成
' ============================================
interface ICodeGenerator INTERFACE_COLOR {
    + Generate(ast: AST, allocation: AllocationResult): string
    + EmitInstruction(instruction: Instruction): string
}

class MipsCodeGenerator {
    - _allocation: AllocationResult
    - _labelCounter: int
    --
    + Generate(ast: AST, allocation: AllocationResult): string
    + EmitInstruction(instruction: Instruction): string
    --
    # EmitDataSection(data: DataSection): string
    # EmitTextSection(text: TextSection): string
    # TranslateVirtualRegister(vreg: VirtualRegister): PhysicalRegister
    # OptimizePeephole(code: string): string
}

ICodeGenerator <|.. MipsCodeGenerator

' ============================================
' アセンブラ
' ============================================
interface IAssembler INTERFACE_COLOR {
    + Assemble(source: string): AssemblyResult
    + Disassemble(binary: byte[]): string
}

class Assembler {
    - _instructionEncoder: IInstructionEncoder
    - _symbolTable: SymbolTable
    --
    + Assemble(source: string): AssemblyResult
    + Disassemble(binary: byte[]): string
    --
    # FirstPass(source: string): SymbolTable
    # SecondPass(source: string, symbols: SymbolTable): byte[]
    # ResolveLabels(address: uint, symbols: SymbolTable): uint
}

IAssembler <|.. Assembler

interface IInstructionEncoder INTERFACE_COLOR {
    + Encode(instruction: Instruction): uint
    + Decode(binary: uint): Instruction
}

class MipsInstructionEncoder {
    - _opcodeTable: Dictionary<string, byte>
    --
    + Encode(instruction: Instruction): uint
    + Decode(binary: uint): Instruction
    --
    # EncodeRType(instruction: RInstruction): uint
    # EncodeIType(instruction: IInstruction): uint
    # EncodeJType(instruction: JInstruction): uint
}

IInstructionEncoder <|.. MipsInstructionEncoder
Assembler o--> IInstructionEncoder

' ============================================
' ドメインモデル
' ============================================
class AST {
    + Root: ProgramNode
    + DataSection: DataSection
    + TextSection: TextSection
    --
    + Accept(visitor: IASTVisitor): void
    + GetAllNodes(): IEnumerable<ASTNode>
}

abstract class ASTNode {
    + Line: int
    + Column: int
    + Parent: ASTNode?
    --
    + {abstract} Accept(visitor: IASTVisitor): void
}

class Statement extends ASTNode
class Instruction extends Statement
class LetStatement extends Statement {
    + Target: VirtualRegister
    + Expression: Expression
}

class Expression extends ASTNode
class BinaryExpression extends Expression {
    + Left: Expression
    + Operator: BinaryOperator
    + Right: Expression
}

AST *-- "1" ProgramNode
ProgramNode *-- "*" Statement

class InterferenceGraph {
    - _adjacencyList: Dictionary<VirtualRegister, HashSet<VirtualRegister>>
    --
    + AddEdge(v1: VirtualRegister, v2: VirtualRegister): void
    + Neighbors(v: VirtualRegister): ISet<VirtualRegister>
    + Degree(v: VirtualRegister): int
    + Remove(v: VirtualRegister): void
    + Clone(): InterferenceGraph
}

class VirtualRegister <<Value Object>> {
    + Id: int
    + Name: string
    --
    + Equals(other: VirtualRegister): bool
    + GetHashCode(): int
}

class PhysicalRegister <<Value Object>> {
    + Number: int
    + Name: string
    + Type: RegisterType
    --
    + {static} T0, T1, ..., T9: PhysicalRegister
    + {static} S0, S1, ..., S7: PhysicalRegister
}

enum RegisterType {
    Temporary
    Saved
    Argument
    Return
    Special
}

PhysicalRegister --> RegisterType

class AllocationResult {
    + Mapping: IReadOnlyDictionary<VirtualRegister, PhysicalRegister>
    + SpilledRegisters: IReadOnlySet<VirtualRegister>
    + SpillCode: IReadOnlyList<Instruction>
    + Success: bool
}

AllocationResult o-- "*" VirtualRegister
AllocationResult o-- "*" PhysicalRegister

class LiveRange <<Value Object>> {
    + Register: VirtualRegister
    + StartPoint: int
    + EndPoint: int
    --
    + Overlaps(other: LiveRange): bool
}

LiveRange --> VirtualRegister

class ControlFlowGraph {
    - _blocks: List<BasicBlock>
    - _edges: Dictionary<BasicBlock, List<BasicBlock>>
    --
    + AddBlock(block: BasicBlock): void
    + AddEdge(from: BasicBlock, to: BasicBlock): void
    + GetPredecessors(block: BasicBlock): IEnumerable<BasicBlock>
    + GetSuccessors(block: BasicBlock): IEnumerable<BasicBlock>
    + TopologicalSort(): IEnumerable<BasicBlock>
}

class BasicBlock {
    + Id: int
    + Instructions: List<Instruction>
    + LiveIn: HashSet<VirtualRegister>
    + LiveOut: HashSet<VirtualRegister>
}

ControlFlowGraph *-- "*" BasicBlock

class SymbolTable {
    - _symbols: Dictionary<string, Symbol>
    --
    + Define(name: string, address: uint): void
    + Resolve(name: string): Symbol?
    + Contains(name: string): bool
}

class Symbol <<Value Object>> {
    + Name: string
    + Address: uint
    + Type: SymbolType
}

enum SymbolType {
    Label
    Data
    Function
}

SymbolTable *-- "*" Symbol
Symbol --> SymbolType

' ============================================
' 結果型
' ============================================
class CompilationResult {
    + Success: bool
    + Binary: byte[]
    + SourceMap: SourceMap
    + Errors: IReadOnlyList<CompilationError>
    + TranspiledSource: string?
}

class SourceMap {
    + GetSourceLine(address: uint): int?
    + GetAddress(line: int): uint?
}

CompilationResult *-- "1" SourceMap

class CompilationError {
    + Line: int
    + Column: int
    + Message: string
    + Severity: ErrorSeverity
}

enum ErrorSeverity {
    Error
    Warning
    Info
}

CompilationResult *-- "*" CompilationError
CompilationError --> ErrorSeverity

class Token <<Value Object>> {
    + Type: TokenType
    + Lexeme: string
    + Line: int
    + Column: int
}

enum TokenType {
    VirtualRegister
    PhysicalRegister
    ExtendedKeyword
    Identifier
    Number
    Operator
    ...
}

Token --> TokenType

' ============================================
' ビジターパターン (拡張性)
' ============================================
interface IASTVisitor INTERFACE_COLOR {
    + VisitProgram(node: ProgramNode): void
    + VisitStatement(node: Statement): void
    + VisitExpression(node: Expression): void
}

note right of IASTVisitor
  オープン・クローズドの原則:
  新しい操作を追加する際、
  既存コードを変更せずに
  Visitorを追加できる
end note

@enduml
