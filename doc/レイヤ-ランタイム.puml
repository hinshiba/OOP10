@startuml Runtime Layer Detail

!define INTERFACE_COLOR #C8E6C9
!define ABSTRACT_COLOR #FFE0B2

skinparam linetype ortho

' ============================================
' レイヤー間インターフェース (Facade)
' ============================================
interface IDebuggerService INTERFACE_COLOR {
    + StartDebugging(program: byte[], sourceMap: SourceMap): Task
    + StepInto(): Task
    + StepOver(): Task
    + StepOut(): Task
    + Continue(): Task
    + Pause(): void
    + Stop(): void
    + SetBreakpoint(line: int, condition: string?): Guid
    + RemoveBreakpoint(id: Guid): bool
    + TravelTo(snapshotId: Guid): Task
    + GetCurrentState(): ExecutionState
}

interface IRuntimeService INTERFACE_COLOR {
    + LoadProgram(binary: byte[], entryPoint: uint): Task
    + Reset(): void
    + ExecuteInstruction(): Task<ExecutionResult>
    + GetRegisterValue(register: int): uint
    + GetMemoryValue(address: uint, size: int): byte[]
    + SetRegisterValue(register: int, value: uint): void
    + SetMemoryValue(address: uint, data: byte[]): void
}

class DebuggerService {
    - _processor: IProcessor
    - _debugger: IDebugger
    - _timeTravel: ITimeTravel
    - _breakpointMgr: IBreakpointManager
    --
    + StartDebugging(program: byte[], sourceMap: SourceMap): Task
    + StepInto(): Task
    + StepOver(): Task
    + StepOut(): Task
    + Continue(): Task
    + Pause(): void
    + Stop(): void
    + SetBreakpoint(line: int, condition: string?): Guid
    + RemoveBreakpoint(id: Guid): bool
    + TravelTo(snapshotId: Guid): Task
    + GetCurrentState(): ExecutionState
    --
    # ShouldBreak(): bool
    # NotifyStateChanged(): void
}

class RuntimeService {
    - _processor: IProcessor
    - _memory: IMemory
    - _registers: IRegisterFile
    --
    + LoadProgram(binary: byte[], entryPoint: uint): Task
    + Reset(): void
    + ExecuteInstruction(): Task<ExecutionResult>
    + GetRegisterValue(register: int): uint
    + GetMemoryValue(address: uint, size: int): byte[]
    + SetRegisterValue(register: int, value: uint): void
    + SetMemoryValue(address: uint, data: byte[]): void
}

IDebuggerService <|.. DebuggerService
IRuntimeService <|.. RuntimeService

' ============================================
' プロセッサコア
' ============================================
interface IProcessor INTERFACE_COLOR {
    + Registers: IRegisterFile
    + Memory: IMemory
    + PC: uint
    --
    + Execute(): ExecutionResult
    + Reset(): void
    + LoadProgram(binary: byte[], address: uint): void
}

class MipsProcessor {
    - _registers: IRegisterFile
    - _memory: IMemory
    - _pc: uint
    - _hi: uint
    - _lo: uint
    - _instructionDecoder: IInstructionDecoder
    - _executionPipeline: IExecutionPipeline
    --
    + Registers: IRegisterFile
    + Memory: IMemory
    + PC: uint
    --
    + Execute(): ExecutionResult
    + Reset(): void
    + LoadProgram(binary: byte[], address: uint): void
    --
    # Fetch(): uint
    # Decode(instruction: uint): DecodedInstruction
    # ExecuteInstruction(decoded: DecodedInstruction): void
    # HandleException(ex: ProcessorException): void
}

IProcessor <|.. MipsProcessor

' 命令デコーダー (Strategy)
interface IInstructionDecoder INTERFACE_COLOR {
    + Decode(binary: uint): DecodedInstruction
}

class MipsInstructionDecoder {
    - _instructionSet: IInstructionSet
    --
    + Decode(binary: uint): DecodedInstruction
    --
    # DecodeRType(binary: uint): DecodedInstruction
    # DecodeIType(binary: uint): DecodedInstruction
    # DecodeJType(binary: uint): DecodedInstruction
}

IInstructionDecoder <|.. MipsInstructionDecoder
MipsProcessor o--> IInstructionDecoder

' 命令セット (Strategy)
interface IInstructionSet INTERFACE_COLOR {
    + GetInstruction(opcode: byte): IInstruction?
    + SupportedInstructions: IReadOnlyList<IInstruction>
}

class Mips32InstructionSet {
    - _instructions: Dictionary<byte, IInstruction>
    --
    + GetInstruction(opcode: byte): IInstruction?
    + SupportedInstructions: IReadOnlyList<IInstruction>
}

IInstructionSet <|.. Mips32InstructionSet

' 個別命令 (Command Pattern)
interface IInstruction INTERFACE_COLOR {
    + Name: string
    + Opcode: byte
    --
    + Execute(context: ExecutionContext): void
    + CanExecute(context: ExecutionContext): bool
}

abstract class BaseInstruction {
    + Name: string
    + Opcode: byte
    --
    + {abstract} Execute(context: ExecutionContext): void
    + CanExecute(context: ExecutionContext): bool
}

class AddInstruction extends BaseInstruction {
    + Execute(context: ExecutionContext): void
}

class LoadWordInstruction extends BaseInstruction {
    + Execute(context: ExecutionContext): void
}

class BranchInstruction extends BaseInstruction {
    + Execute(context: ExecutionContext): void
}

IInstruction <|.. BaseInstruction

' 実行コンテキスト
class ExecutionContext {
    + Registers: IRegisterFile
    + Memory: IMemory
    + PC: ref uint
    + HI: ref uint
    + LO: ref uint
    --
    + ReadRegister(index: int): uint
    + WriteRegister(index: int, value: uint): void
    + ReadMemory(address: uint, size: int): byte[]
    + WriteMemory(address: uint, data: byte[]): void
}

BaseInstruction ..> ExecutionContext

' 実行パイプライン (Chain of Responsibility)
interface IExecutionPipeline INTERFACE_COLOR {
    + AddStage(stage: IPipelineStage): void
    + Execute(instruction: DecodedInstruction, context: ExecutionContext): void
}

class ExecutionPipeline {
    - _stages: List<IPipelineStage>
    --
    + AddStage(stage: IPipelineStage): void
    + Execute(instruction: DecodedInstruction, context: ExecutionContext): void
}

interface IPipelineStage INTERFACE_COLOR {
    + Process(instruction: DecodedInstruction, context: ExecutionContext): void
}

class ValidationStage implements IPipelineStage {
    + Process(instruction: DecodedInstruction, context: ExecutionContext): void
}

class ExecutionStage implements IPipelineStage {
    + Process(instruction: DecodedInstruction, context: ExecutionContext): void
}

class WritebackStage implements IPipelineStage {
    + Process(instruction: DecodedInstruction, context: ExecutionContext): void
}

IExecutionPipeline <|.. ExecutionPipeline
ExecutionPipeline o--> "*" IPipelineStage
MipsProcessor o--> IExecutionPipeline

' ============================================
' レジスタファイル
' ============================================
interface IRegisterFile INTERFACE_COLOR {
    + Read(index: int): uint
    + Write(index: int, value: uint): void
    + Reset(): void
    + GetSnapshot(): RegisterSnapshot
    + RestoreSnapshot(snapshot: RegisterSnapshot): void
}

class RegisterFile {
    - _registers: uint[32]
    - _readOnlyIndices: HashSet<int>
    --
    + Read(index: int): uint
    + Write(index: int, value: uint): void
    + Reset(): void
    + GetSnapshot(): RegisterSnapshot
    + RestoreSnapshot(snapshot: RegisterSnapshot): void
    --
    # ValidateIndex(index: int): void
    # ValidateWrite(index: int): void
}

IRegisterFile <|.. RegisterFile

class RegisterSnapshot <<Value Object>> {
    + Values: uint[]
    + Timestamp: DateTime
    --
    + Clone(): RegisterSnapshot
}

RegisterFile ..> RegisterSnapshot

' ============================================
' メモリ管理
' ============================================
interface IMemory INTERFACE_COLOR {
    + Read(address: uint, size: int): byte[]
    + Write(address: uint, data: byte[]): void
    + Allocate(size: uint): uint
    + IsValidAddress(address: uint): bool
    + GetSnapshot(): MemorySnapshot
    + RestoreSnapshot(snapshot: MemorySnapshot): void
}

class Memory {
    - _segments: Dictionary<MemorySegmentType, IMemorySegment>
    - _addressTranslator: IAddressTranslator
    --
    + Read(address: uint, size: int): byte[]
    + Write(address: uint, data: byte[]): void
    + Allocate(size: uint): uint
    + IsValidAddress(address: uint): bool
    + GetSnapshot(): MemorySnapshot
    + RestoreSnapshot(snapshot: MemorySnapshot): void
    --
    # ResolveSegment(address: uint): IMemorySegment
}

IMemory <|.. Memory

' メモリセグメント (Strategy)
interface IMemorySegment INTERFACE_COLOR {
    + BaseAddress: uint
    + Size: uint
    + Type: MemorySegmentType
    --
    + Read(offset: uint, size: int): byte[]
    + Write(offset: uint, data: byte[]): void
    + Clear(): void
}

class TextSegment implements IMemorySegment {
    - _data: byte[]
    - _readOnly: bool
}

class DataSegment implements IMemorySegment {
    - _data: byte[]
}

class HeapSegment implements IMemorySegment {
    - _data: byte[]
    - _allocator: IHeapAllocator
}

class StackSegment implements IMemorySegment {
    - _data: byte[]
    - _stackPointer: uint
}

enum MemorySegmentType {
    Text
    Data
    Heap
    Stack
}

Memory o--> "*" IMemorySegment

' アドレス変換
interface IAddressTranslator INTERFACE_COLOR {
    + TranslateVirtual(address: uint): PhysicalAddress
    + IsValidAddress(address: uint): bool
}

class SimpleAddressTranslator implements IAddressTranslator {
    + TranslateVirtual(address: uint): PhysicalAddress
    + IsValidAddress(address: uint): bool
}

Memory o--> IAddressTranslator

' ヒープアロケータ
interface IHeapAllocator INTERFACE_COLOR {
    + Allocate(size: uint): uint?
    + Free(address: uint): bool
}

class FirstFitAllocator implements IHeapAllocator {
    - _freeBlocks: List<MemoryBlock>
}

HeapSegment o--> IHeapAllocator

' メモリスナップショット (Memento Pattern)
class MemorySnapshot {
    + Deltas: Dictionary<uint, byte[]>
    + FullSnapshot: byte[]?
    + Timestamp: DateTime
    --
    + GetDiff(previous: MemorySnapshot): Dictionary<uint, byte[]>
    + Merge(deltas: Dictionary<uint, byte[]>): MemorySnapshot
}

Memory ..> MemorySnapshot

' ============================================
' デバッガ
' ============================================
interface IDebugger INTERFACE_COLOR {
    + State: DebugState
    + SourceMap: SourceMap
    --
    + Attach(processor: IProcessor): void
    + Step(): Task
    + Continue(): Task
    + Pause(): void
    + GetCallStack(): IReadOnlyList<StackFrame>
}

class Debugger {
    - _processor: IProcessor
    - _breakpointManager: IBreakpointManager
    - _watchpointManager: IWatchpointManager
    - _state: DebugState
    - _sourceMap: SourceMap
    - _callStack: Stack<StackFrame>
    --
    + State: DebugState
    + SourceMap: SourceMap
    --
    + Attach(processor: IProcessor): void
    + Step(): Task
    + Continue(): Task
    + Pause(): void
    + GetCallStack(): IReadOnlyList<StackFrame>
    --
    # OnInstructionExecuted(pc: uint): void
    # OnMemoryChanged(address: uint): void
    # EvaluateBreakConditions(): bool
    # UpdateCallStack(pc: uint): void
}

IDebugger <|.. Debugger

enum DebugState {
    Idle
    Running
    Paused
    Stepping
    Finished
}

Debugger --> DebugState

' ブレークポイント管理
interface IBreakpointManager INTERFACE_COLOR {
    + Add(breakpoint: IBreakpoint): Guid
    + Remove(id: Guid): bool
    + GetAll(): IReadOnlyList<IBreakpoint>
    + ShouldBreak(context: ExecutionContext): IBreakpoint?
}

class BreakpointManager {
    - _breakpoints: Dictionary<Guid, IBreakpoint>
    - _addressIndex: Dictionary<uint, List<Guid>>
    --
    + Add(breakpoint: IBreakpoint): Guid
    + Remove(id: Guid): bool
    + GetAll(): IReadOnlyList<IBreakpoint>
    + ShouldBreak(context: ExecutionContext): IBreakpoint?
}

IBreakpointManager <|.. BreakpointManager
Debugger o--> IBreakpointManager

' ブレークポイント (Strategy + Composite)
interface IBreakpoint INTERFACE_COLOR {
    + Id: Guid
    + Enabled: bool
    + HitCount: int
    --
    + IsTriggered(context: ExecutionContext): bool
    + OnHit(): void
}

abstract class BaseBreakpoint {
    + Id: Guid
    + Enabled: bool
    + HitCount: int
    --
    + {abstract} IsTriggered(context: ExecutionContext): bool
    + OnHit(): void
}

class LineBreakpoint extends BaseBreakpoint {
    + Line: int
    + SourceMap: SourceMap
    --
    + IsTriggered(context: ExecutionContext): bool
}

class ConditionalBreakpoint extends BaseBreakpoint {
    + Condition: IConditionExpression
    --
    + IsTriggered(context: ExecutionContext): bool
}

class DataBreakpoint extends BaseBreakpoint {
    + Address: uint
    + WatchType: WatchType
    - _previousValue: byte[]?
    --
    + IsTriggered(context: ExecutionContext): bool
}

enum WatchType {
    Read
    Write
    ReadWrite
}

IBreakpoint <|.. BaseBreakpoint
DataBreakpoint --> WatchType

' 条件式評価 (Interpreter Pattern)
interface IConditionExpression INTERFACE_COLOR {
    + Evaluate(context: ExecutionContext): bool
}

class ComparisonExpression implements IConditionExpression {
    + Left: IValueExpression
    + Operator: ComparisonOperator
    + Right: IValueExpression
    --
    + Evaluate(context: ExecutionContext): bool
}

class LogicalExpression implements IConditionExpression {
    + Left: IConditionExpression
    + Operator: LogicalOperator
    + Right: IConditionExpression
    --
    + Evaluate(context: ExecutionContext): bool
}

ConditionalBreakpoint o--> IConditionExpression

' ウォッチポイント
interface IWatchpointManager INTERFACE_COLOR {
    + AddWatch(expression: string): Guid
    + RemoveWatch(id: Guid): bool
    + EvaluateAll(context: ExecutionContext): Dictionary<Guid, object>
}

class WatchpointManager implements IWatchpointManager {
    - _watches: Dictionary<Guid, IWatchExpression>
}

Debugger o--> IWatchpointManager

' ============================================
' タイムトラベル
' ============================================
interface ITimeTravel INTERFACE_COLOR {
    + IsEnabled: bool
    + CurrentSnapshot: Guid
    + SnapshotCount: int
    --
    + EnableRecording(maxSnapshots: int): void
    + DisableRecording(): void
    + TakeSnapshot(): Guid
    + RestoreSnapshot(id: Guid): bool
    + GetSnapshots(): IReadOnlyList<ExecutionSnapshot>
    + GetTimeline(): Timeline
    + Clear(): void
}

class TimeTravelEngine {
    - _snapshots: LinkedList<ExecutionSnapshot>
    - _currentNode: LinkedListNode<ExecutionSnapshot>?
    - _maxSnapshots: int
    - _isEnabled: bool
    - _processor: IProcessor
    --
    + IsEnabled: bool
    + CurrentSnapshot: Guid
    + SnapshotCount: int
    --
    + EnableRecording(maxSnapshots: int): void
    + DisableRecording(): void
    + TakeSnapshot(): Guid
    + RestoreSnapshot(id: Guid): bool
    + GetSnapshots(): IReadOnlyList<ExecutionSnapshot>
    + GetTimeline(): Timeline
    + Clear(): void
    --
    # CompressSnapshots(): void
    # PruneOldSnapshots(): void
}

ITimeTravel <|.. TimeTravelEngine

' スナップショット (Memento Pattern)
class ExecutionSnapshot {
    + Id: Guid
    + Timestamp: DateTime
    + InstructionCount: long
    + PC: uint
    + RegisterSnapshot: RegisterSnapshot
    + MemorySnapshot: MemorySnapshot
    + CallStack: IReadOnlyList<StackFrame>
    --
    + CalculateSize(): long
}

TimeTravelEngine o--> "*" ExecutionSnapshot

class Timeline {
    + Snapshots: IReadOnlyList<TimelineEntry>
    --
    + GetRange(start: DateTime, end: DateTime): IEnumerable<TimelineEntry>
}

class TimelineEntry <<Value Object>> {
    + SnapshotId: Guid
    + Timestamp: DateTime
    + PC: uint
    + Line: int
    + EventType: TimelineEventType
}

enum TimelineEventType {
    Instruction
    Branch
    FunctionCall
    FunctionReturn
    Syscall
    Exception
}

Timeline *-- "*" TimelineEntry
TimelineEntry --> TimelineEventType

' ============================================
' システムコール
' ============================================
interface ISyscallHandler INTERFACE_COLOR {
    + Handle(syscallNumber: int, context: ExecutionContext): void
    + RegisterSyscall(number: int, handler: Action<ExecutionContext>): void
}

class SyscallHandler {
    - _handlers: Dictionary<int, Action<ExecutionContext>>
    - _ioProvider: IIOProvider
    --
    + Handle(syscallNumber: int, context: ExecutionContext): void
    + RegisterSyscall(number: int, handler: Action<ExecutionContext>): void
    --
    # PrintInt(context: ExecutionContext): void
    # PrintString(context: ExecutionContext): void
    # ReadInt(context: ExecutionContext): void
    # Sbrk(context: ExecutionContext): void
}

ISyscallHandler <|.. SyscallHandler
MipsProcessor o--> ISyscallHandler

' I/O抽象化 (Dependency Inversion)
interface IIOProvider INTERFACE_COLOR {
    + ReadLine(): string
    + WriteLine(text: string): void
    + ReadChar(): char
    + WriteChar(c: char): void
}

class ConsoleIOProvider implements IIOProvider
class GUIIOProvider implements IIOProvider

SyscallHandler o--> IIOProvider

' ============================================
' 例外処理
' ============================================
class ProcessorException extends Exception {
    + ExceptionType: ExceptionType
    + PC: uint
    + Address: uint?
}

enum ExceptionType {
    ArithmeticOverflow
    DivisionByZero
    InvalidAddress
    AlignmentError
    InvalidInstruction
    BreakpointHit
}

ProcessorException --> ExceptionType

' ============================================
' 実行結果
' ============================================
class ExecutionResult {
    + Success: bool
    + PC: uint
    + InstructionExecuted: DecodedInstruction?
    + CyclesElapsed: int
    + Exception: ProcessorException?
    + ShouldBreak: bool
}

class ExecutionState {
    + PC: uint
    + Registers: uint[]
    + CallStack: IReadOnlyList<StackFrame>
    + IsRunning: bool
    + CurrentLine: int
}

class StackFrame {
    + FunctionName: string
    + PC: uint
    + ReturnAddress: uint
    + FramePointer: uint
    + LocalVariables: Dictionary<string, uint>
}

ExecutionState *-- "*" StackFrame

class DecodedInstruction {
    + Opcode: byte
    + Format: InstructionFormat
    + Rs: byte?
    + Rt: byte?
    + Rd: byte?
    + Immediate: ushort?
    + Address: uint?
}

enum InstructionFormat {
    RType
    IType
    JType
}

DecodedInstruction --> InstructionFormat

' ============================================
' イベント通知 (Observer Pattern)
' ============================================
interface IProcessorObserver INTERFACE_COLOR {
    + OnInstructionExecuted(result: ExecutionResult): void
    + OnRegisterChanged(index: int, oldValue: uint, newValue: uint): void
    + OnMemoryChanged(address: uint, size: int): void
    + OnException(exception: ProcessorException): void
}

class ProcessorEventBus {
    - _observers: List<IProcessorObserver>
    --
    + Subscribe(observer: IProcessorObserver): void
    + Unsubscribe(observer: IProcessorObserver): void
    + NotifyInstructionExecuted(result: ExecutionResult): void
    + NotifyRegisterChanged(index: int, oldValue: uint, newValue: uint): void
    + NotifyMemoryChanged(address: uint, size: int): void
    + NotifyException(exception: ProcessorException): void
}

MipsProcessor o--> ProcessorEventBus
ProcessorEventBus o--> "*" IProcessorObserver
Debugger ..|> IProcessorObserver
TimeTravelEngine ..|> IProcessorObserver

note right of IBreakpoint
  Strategy Pattern:
  様々なブレークポイント戦略を
  統一インターフェースで扱う
end note

note bottom of ExecutionSnapshot
  Memento Pattern:
  実行状態を保存・復元
  (タイムトラベル)
end note

note right of IInstruction
  Command Pattern:
  各命令を実行可能オブジェクトとして実装
  Undo/Redoも可能
end note

@enduml
