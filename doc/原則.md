# MIPS Debugger - SOLID原則と設計パターン適用

## 目次
1. [レイヤー構造と依存性逆転](#レイヤー構造と依存性逆転)
2. [SOLID原則の適用](#solid原則の適用)
3. [設計パターンの活用](#設計パターンの活用)
4. [疎結合・密凝集の実現](#疎結合密凝集の実現)

---

## レイヤー構造と依存性逆転

### 3層アーキテクチャ

```
┌─────────────────────────────────────────────┐
│     Presentation Layer (GUI)                │
│   ┌──────────────────────────────────────┐ │
│   │  ViewModels + Views                  │ │
│   └──────────────────────────────────────┘ │
└─────────────────┬───────────────────────────┘
                  │ depends on (interfaces only)
                  ↓
┌─────────────────────────────────────────────┐
│   Service Interfaces (Abstraction)          │
│   • ICompilerService                        │
│   • IDebuggerService                        │
│   • IRuntimeService                         │
└─────────────────┬───────────────────────────┘
                  ↑ implements
    ┌─────────────┼─────────────┐
    │             │             │
    ↓             ↓             ↓
┌──────────┐ ┌──────────┐ ┌──────────┐
│ Compiler │ │ Runtime  │ │ Debugger │
│  Layer   │ │  Layer   │ │  Layer   │
└──────────┘ └──────────┘ └──────────┘
```

### 依存性逆転の原則 (DIP) 適用

#### ✅ 良い例: Presentation → Service Interface

```csharp
// Presentation Layer
public class MainViewModel : ViewModelBase
{
    private readonly ICompilerService _compilerService;  // インターフェースに依存
    private readonly IDebuggerService _debuggerService;  // インターフェースに依存
    
    public MainViewModel(
        ICompilerService compilerService,
        IDebuggerService debuggerService)  // DIコンテナから注入
    {
        _compilerService = compilerService;
        _debuggerService = debuggerService;
    }
    
    public async Task CompileAsync()
    {
        var result = await _compilerService.CompileAsync(sourceCode);
        // ...
    }
}
```

#### ❌ 悪い例: 具象クラスへの直接依存

```csharp
// アンチパターン
public class MainViewModel
{
    private readonly CompilerService _compilerService;  // 具象クラスに依存
    
    public MainViewModel()
    {
        _compilerService = new CompilerService();  // newで生成
    }
}
```

**理由**:
- テストが困難（モック化できない）
- 実装変更時にPresentation層も変更が必要
- レイヤー間が強結合

---

## SOLID原則の適用

### S: 単一責任の原則 (Single Responsibility Principle)

#### 適用例1: レジスタ割り付けの責務分離

```csharp
// ❌ 悪い例: 1つのクラスが複数の責務を持つ
public class RegisterAllocator
{
    public void Allocate() { /* 割り付け */ }
    public void BuildGraph() { /* グラフ構築 */ }
    public void SpillToStack() { /* スピル処理 */ }
    public void ColorGraph() { /* 彩色 */ }
}

// ✅ 良い例: 責務を分離
public class RegisterAllocator
{
    private readonly IAllocationStrategy _strategy;     // 割り付けアルゴリズム
    private readonly ISpillHandler _spillHandler;       // スピル処理
    
    public AllocationResult Allocate(AST ast, ControlFlowGraph cfg)
    {
        var liveRanges = AnalyzeLiveness(cfg);         // この責務のみ
        var graph = BuildInterferenceGraph(liveRanges); // この責務のみ
        return _strategy.Execute(graph);                // 戦略に委譲
    }
}

// 各戦略は独立したクラス
public class GraphColoringStrategy : IAllocationStrategy { /* ... */ }
public class LinearScanStrategy : IAllocationStrategy { /* ... */ }
public class StackSpillHandler : ISpillHandler { /* ... */ }
```

**利点**:
- 変更理由が1つ（例: グラフ彩色アルゴリズムを変更したい → GraphColoringStrategyのみ変更）
- テストが容易
- 理解しやすい

#### 適用例2: ViewModelの責務分離

```csharp
// ✅ 各ViewModelは単一の責務のみ
public class MainViewModel          // 全体調整のみ
public class EditorViewModel        // エディタ関連のみ
public class RegisterViewModel      // レジスタ表示のみ
public class DebugControlViewModel  // デバッグ制御のみ
```

---

### O: オープン・クローズドの原則 (Open-Closed Principle)

#### 適用例: 命令セットの拡張

```csharp
// ✅ 拡張に開放、修正に閉鎖
public interface IInstruction
{
    string Name { get; }
    byte Opcode { get; }
    void Execute(ExecutionContext context);
}

public abstract class BaseInstruction : IInstruction
{
    public abstract string Name { get; }
    public abstract byte Opcode { get; }
    public abstract void Execute(ExecutionContext context);
    
    public virtual bool CanExecute(ExecutionContext context) => true;
}

// 新しい命令を追加しても既存コードは変更不要
public class AddInstruction : BaseInstruction
{
    public override string Name => "add";
    public override byte Opcode => 0x00;
    
    public override void Execute(ExecutionContext context)
    {
        // add命令の実装
    }
}

public class CustomMultiplyInstruction : BaseInstruction  // 独自拡張
{
    public override string Name => "custom_mul";
    public override byte Opcode => 0xFF;
    
    public override void Execute(ExecutionContext context)
    {
        // カスタム実装
    }
}

// InstructionSetに登録するだけで利用可能
public class Mips32InstructionSet : IInstructionSet
{
    private Dictionary<byte, IInstruction> _instructions;
    
    public void RegisterInstruction(IInstruction instruction)
    {
        _instructions[instruction.Opcode] = instruction;
    }
}
```

**利点**:
- 新しい命令追加時に既存コード変更不要
- プラグイン形式での機能拡張が可能

---

### L: リスコフの置換原則 (Liskov Substitution Principle)

#### 適用例: メモリセグメント

```csharp
// ✅ 基底型で期待される動作を派生型でも保証
public interface IMemorySegment
{
    uint BaseAddress { get; }
    uint Size { get; }
    byte[] Read(uint offset, int size);
    void Write(uint offset, byte[] data);
}

public class TextSegment : IMemorySegment
{
    private readonly byte[] _data;
    private readonly bool _readOnly = true;
    
    public byte[] Read(uint offset, int size)
    {
        // 基底型の契約を守る: 常に成功するか例外
        if (offset + size > Size)
            throw new MemoryAccessException();
        return _data[offset..(offset + size)];
    }
    
    public void Write(uint offset, byte[] data)
    {
        // 基底型の契約を守る: 書き込み不可なら例外
        if (_readOnly)
            throw new WriteProtectedException();
        // ...
    }
}

public class DataSegment : IMemorySegment
{
    // TextSegmentと同じ契約を守る
    public byte[] Read(uint offset, int size) { /* ... */ }
    public void Write(uint offset, byte[] data) { /* ... */ }
}

// 使用側: 型を意識せずに使える
public void ProcessMemory(IMemorySegment segment)
{
    var data = segment.Read(0, 4);  // どのセグメントでも動作
}
```

#### ❌ 違反例

```csharp
// アンチパターン
public class BrokenTextSegment : IMemorySegment
{
    public byte[] Read(uint offset, int size)
    {
        return null;  // 契約違反: nullを返してはいけない
    }
}
```

---

### I: インターフェース分離の原則 (Interface Segregation Principle)

#### 適用例: デバッガインターフェースの分離

```csharp
// ❌ 悪い例: 巨大なインターフェース
public interface IDebugger
{
    void Step();
    void Continue();
    void SetBreakpoint();
    void RemoveBreakpoint();
    void TakeSnapshot();
    void RestoreSnapshot();
    void EnableRecording();
    void DisableRecording();
    // ... 20個以上のメソッド
}

// ✅ 良い例: 責務ごとに分離
public interface IDebugger
{
    DebugState State { get; }
    Task Step();
    Task Continue();
    void Pause();
}

public interface IBreakpointManager
{
    Guid Add(IBreakpoint breakpoint);
    bool Remove(Guid id);
    IBreakpoint? ShouldBreak(ExecutionContext context);
}

public interface ITimeTravel
{
    bool IsEnabled { get; }
    Guid TakeSnapshot();
    bool RestoreSnapshot(Guid id);
    void EnableRecording(int maxSnapshots);
}

// 使用側は必要なインターフェースのみ依存
public class StepExecutor
{
    private readonly IDebugger _debugger;  // タイムトラベル不要
    
    public StepExecutor(IDebugger debugger)
    {
        _debugger = debugger;
    }
}

public class TimeTravelViewModel
{
    private readonly ITimeTravel _timeTravel;  // デバッグ制御不要
    
    public TimeTravelViewModel(ITimeTravel timeTravel)
    {
        _timeTravel = timeTravel;
    }
}
```

**利点**:
- 不要な依存を持たない
- インターフェース変更の影響範囲が小さい
- テストが容易

---

### D: 依存性逆転の原則 (既出)

上位レイヤーは下位レイヤーの抽象（インターフェース）に依存し、  
下位レイヤーの実装詳細には依存しない。

---

## 設計パターンの活用

### 1. Strategy Pattern（戦略パターン）

**適用箇所**: レジスタ割り付けアルゴリズム

```csharp
public interface IAllocationStrategy
{
    Coloring Execute(InterferenceGraph graph);
}

public class GraphColoringStrategy : IAllocationStrategy { /* ... */ }
public class LinearScanStrategy : IAllocationStrategy { /* ... */ }

// 実行時に戦略を切り替え可能
public class RegisterAllocator
{
    private IAllocationStrategy _strategy;
    
    public void SetStrategy(IAllocationStrategy strategy)
    {
        _strategy = strategy;
    }
    
    public AllocationResult Allocate(AST ast)
    {
        // ...
        return _strategy.Execute(graph);
    }
}
```

**利点**: アルゴリズムの切り替えが容易（設定で変更可能）

---

### 2. Command Pattern（コマンドパターン）

**適用箇所1**: 命令実行

```csharp
public interface IInstruction
{
    void Execute(ExecutionContext context);
}

// 各命令がコマンドオブジェクト
public class AddInstruction : IInstruction
{
    public void Execute(ExecutionContext context)
    {
        var result = context.ReadRegister(rs) + context.ReadRegister(rt);
        context.WriteRegister(rd, result);
    }
}
```

**適用箇所2**: UI操作

```csharp
public interface ICommand
{
    bool CanExecute(object? parameter);
    void Execute(object? parameter);
}

public class AsyncCommand : ICommand
{
    private readonly Func<Task> _execute;
    
    public void Execute(object? parameter)
    {
        _ = _execute();
    }
}

// ViewModelでの使用
public ICommand CompileCommand { get; }

CompileCommand = new AsyncCommand(async () =>
{
    await _compilerService.CompileAsync(sourceCode);
});
```

**利点**: 
- Undo/Redo実装が容易
- マクロ記録が可能
- UIとロジックの分離

---

### 3. Memento Pattern（メメントパターン）

**適用箇所**: タイムトラベルデバッグ

```csharp
// Originator
public class MipsProcessor
{
    public ExecutionSnapshot CreateSnapshot()
    {
        return new ExecutionSnapshot
        {
            PC = this.PC,
            Registers = _registers.GetSnapshot(),
            Memory = _memory.GetSnapshot()
        };
    }
    
    public void RestoreSnapshot(ExecutionSnapshot snapshot)
    {
        this.PC = snapshot.PC;
        _registers.RestoreSnapshot(snapshot.Registers);
        _memory.RestoreSnapshot(snapshot.Memory);
    }
}

// Memento
public class ExecutionSnapshot
{
    public uint PC { get; set; }
    public RegisterSnapshot Registers { get; set; }
    public MemorySnapshot Memory { get; set; }
}

// Caretaker
public class TimeTravelEngine
{
    private LinkedList<ExecutionSnapshot> _snapshots;
    
    public Guid TakeSnapshot()
    {
        var snapshot = _processor.CreateSnapshot();
        _snapshots.AddLast(snapshot);
        return snapshot.Id;
    }
    
    public void RestoreSnapshot(Guid id)
    {
        var snapshot = _snapshots.First(s => s.Id == id);
        _processor.RestoreSnapshot(snapshot);
    }
}
```

**利点**: 状態の保存・復元を安全に実装

---

### 4. Observer Pattern（オブザーバーパターン）

**適用箇所**: 実行状態の変更通知

```csharp
public interface IProcessorObserver
{
    void OnInstructionExecuted(ExecutionResult result);
    void OnRegisterChanged(int index, uint oldValue, uint newValue);
    void OnMemoryChanged(uint address, int size);
}

public class ProcessorEventBus
{
    private List<IProcessorObserver> _observers = new();
    
    public void Subscribe(IProcessorObserver observer)
    {
        _observers.Add(observer);
    }
    
    public void NotifyInstructionExecuted(ExecutionResult result)
    {
        foreach (var observer in _observers)
            observer.OnInstructionExecuted(result);
    }
}

// 購読者
public class Debugger : IProcessorObserver
{
    public void OnInstructionExecuted(ExecutionResult result)
    {
        UpdateCallStack(result.PC);
        CheckBreakpoints();
    }
}

public class TimeTravelEngine : IProcessorObserver
{
    public void OnInstructionExecuted(ExecutionResult result)
    {
        if (_isEnabled)
            TakeSnapshot();
    }
}
```

**利点**: 
- 疎結合（Processorは購読者を知らない）
- 動的な購読/解除が可能

---

### 5. Facade Pattern（ファサードパターン）

**適用箇所**: レイヤー間インターフェース

```csharp
// Presentation層からCompiler層への単純化されたインターフェース
public interface ICompilerService
{
    Task<CompilationResult> CompileAsync(string source);
    Task<string> TranspileExtendedSyntax(string source);
    RegisterAllocationInfo GetAllocationInfo();
}

// 内部では複雑な処理を隠蔽
public class CompilerService : ICompilerService
{
    private readonly ILexer _lexer;
    private readonly IParser _parser;
    private readonly IRegisterAllocator _allocator;
    private readonly ICodeGenerator _generator;
    private readonly IAssembler _assembler;
    
    public async Task<CompilationResult> CompileAsync(string source)
    {
        var tokens = _lexer.Tokenize(source);
        var ast = _parser.Parse(tokens);
        var allocation = _allocator.Allocate(ast);
        var code = _generator.Generate(ast, allocation);
        var binary = _assembler.Assemble(code);
        
        return new CompilationResult { Binary = binary };
    }
}
```

**利点**: 複雑なサブシステムを簡単なインターフェースで隠蔽

---

### 6. Builder Pattern（ビルダーパターン）

**適用箇所**: 干渉グラフ構築

```csharp
public class InterferenceGraphBuilder
{
    private Dictionary<VirtualRegister, HashSet<VirtualRegister>> _adjacency = new();
    
    public InterferenceGraphBuilder AddNode(VirtualRegister register)
    {
        if (!_adjacency.ContainsKey(register))
            _adjacency[register] = new HashSet<VirtualRegister>();
        return this;
    }
    
    public InterferenceGraphBuilder AddEdge(VirtualRegister v1, VirtualRegister v2)
    {
        _adjacency[v1].Add(v2);
        _adjacency[v2].Add(v1);
        return this;
    }
    
    public InterferenceGraph Build()
    {
        return new InterferenceGraph(_adjacency);
    }
}

// 使用例
var graph = new InterferenceGraphBuilder()
    .AddNode(v0)
    .AddNode(v1)
    .AddEdge(v0, v1)
    .Build();
```

---

### 7. Visitor Pattern（ビジターパターン）

**適用箇所**: AST走査

```csharp
public interface IASTVisitor
{
    void VisitProgram(ProgramNode node);
    void VisitStatement(Statement node);
    void VisitExpression(Expression node);
}

public abstract class ASTNode
{
    public abstract void Accept(IASTVisitor visitor);
}

public class Statement : ASTNode
{
    public override void Accept(IASTVisitor visitor)
    {
        visitor.VisitStatement(this);
    }
}

// 様々な操作をVisitorとして実装
public class CodeGeneratorVisitor : IASTVisitor
{
    public void VisitStatement(Statement node)
    {
        // コード生成
    }
}

public class SemanticAnalyzerVisitor : IASTVisitor
{
    public void VisitStatement(Statement node)
    {
        // 意味解析
    }
}
```

**利点**: 新しい操作追加時にASTノードを変更不要

---

### 8. Chain of Responsibility Pattern（責任の連鎖パターン）

**適用箇所**: 実行パイプライン

```csharp
public interface IPipelineStage
{
    void Process(DecodedInstruction instruction, ExecutionContext context);
}

public class ExecutionPipeline
{
    private List<IPipelineStage> _stages = new();
    
    public void AddStage(IPipelineStage stage)
    {
        _stages.Add(stage);
    }
    
    public void Execute(DecodedInstruction instruction, ExecutionContext context)
    {
        foreach (var stage in _stages)
        {
            stage.Process(instruction, context);
        }
    }
}

// ステージ
public class ValidationStage : IPipelineStage
{
    public void Process(DecodedInstruction instruction, ExecutionContext context)
    {
        // 妥当性検証
    }
}

public class ExecutionStage : IPipelineStage
{
    public void Process(DecodedInstruction instruction, ExecutionContext context)
    {
        // 実行
    }
}
```

---

## 疎結合・密凝集の実現

### 疎結合（Loose Coupling）

#### 実現方法

1. **インターフェースを介した通信**
```csharp
// ✅ 疎結合
public class MainViewModel
{
    private readonly ICompilerService _compiler;  // インターフェース
    
    public MainViewModel(ICompilerService compiler)
    {
        _compiler = compiler;
    }
}

// ❌ 密結合
public class MainViewModel
{
    private readonly CompilerService _compiler;  // 具象クラス
    
    public MainViewModel()
    {
        _compiler = new CompilerService();
    }
}
```

2. **依存性注入（DI）**
```csharp
// Startup.cs または App.axaml.cs
services.AddSingleton<ICompilerService, CompilerService>();
services.AddSingleton<IDebuggerService, DebuggerService>();
services.AddSingleton<IRuntimeService, RuntimeService>();
```

3. **イベントベース通信**
```csharp
// Observable使用（ReactiveUI）
public class DebuggerService
{
    public IObservable<ExecutionState> StateChanged { get; }
}

public class RegisterViewModel
{
    public RegisterViewModel(IDebuggerService debugger)
    {
        debugger.StateChanged
            .Subscribe(state => UpdateRegisters());
    }
}
```

#### 利点

- コンポーネント間の依存が最小限
- テストが容易（モック注入可能）
- 実装変更の影響が局所的

---

### 密凝集（High Cohesion）

#### 実現方法

**各クラスは関連する機能のみを持つ**

```csharp
// ✅ 密凝集: レジスタ割り付けに関する機能のみ
public class RegisterAllocator
{
    public AllocationResult Allocate(AST ast, ControlFlowGraph cfg)
    public InterferenceGraph BuildInterferenceGraph(LiveRanges ranges)
    protected LiveRanges AnalyzeLiveness(ControlFlowGraph cfg)
}

// ✅ 密凝集: スピル処理に関する機能のみ
public class StackSpillHandler
{
    public IEnumerable<Instruction> GenerateSpillCode(ISet<VirtualRegister> spillSet)
    public IEnumerable<StackSlot> AllocateStackSlots(int count)
}

// ❌ 低凝集: 無関係な機能が混在
public class RegisterManager
{
    public void AllocateRegisters()  // レジスタ割り付け
    public void GenerateCode()       // コード生成（無関係）
    public void RunDebugger()        // デバッグ実行（無関係）
}
```

**パッケージレベルでの凝集**

```
MipsDebugger.Compiler/          # コンパイル関連のみ
├── Lexer/
├── Parser/
├── RegisterAllocation/
└── CodeGeneration/

MipsDebugger.Runtime/           # 実行関連のみ
├── Processor/
├── Memory/
└── Instructions/

MipsDebugger.Debugger/          # デバッグ関連のみ
├── Breakpoints/
├── TimeTravel/
└── CallStack/

MipsDebugger.Presentation/      # UI関連のみ
├── ViewModels/
└── Views/
```

#### 利点

- 変更の影響範囲が明確
- コードの理解が容易
- 再利用性が高い

---

## レイヤー間通信の具体例

### ✅ 推奨パターン

```csharp
// 1. Presentation → Service Interface → Implementation
public class MainViewModel
{
    private readonly ICompilerService _compiler;
    
    public MainViewModel(ICompilerService compiler)
    {
        _compiler = compiler;  // DI注入
    }
    
    public async Task CompileAsync()
    {
        var result = await _compiler.CompileAsync(sourceCode);
        // ...
    }
}

// 2. 下位レイヤーからの通知はイベント/Observable
public class CompilerService : ICompilerService
{
    public IObservable<CompilationProgress> Progress { get; }
    
    public async Task<CompilationResult> CompileAsync(string source)
    {
        _progressSubject.OnNext(new CompilationProgress(0.5, "Parsing"));
        // ...
    }
}
```

### ❌ アンチパターン

```csharp
// 下位レイヤーが上位レイヤーを直接参照
public class CompilerService
{
    private EditorViewModel _editor;  // 依存方向が逆！
    
    public void Compile()
    {
        _editor.ShowError("Syntax error");  // 依存性逆転違反
    }
}
```

---

## テスト容易性

### 単体テスト例

```csharp
[Fact]
public async Task RegisterAllocator_WithSpill_ShouldGenerateSpillCode()
{
    // Arrange
    var mockStrategy = new Mock<IAllocationStrategy>();
    var mockSpillHandler = new Mock<ISpillHandler>();
    
    mockStrategy
        .Setup(s => s.Execute(It.IsAny<InterferenceGraph>()))
        .Returns(new Coloring { SpillRequired = true });
    
    var allocator = new RegisterAllocator(mockStrategy.Object, mockSpillHandler.Object);
    
    // Act
    var result = allocator.Allocate(ast, cfg);
    
    // Assert
    Assert.True(result.SpilledRegisters.Any());
    mockSpillHandler.Verify(h => h.GenerateSpillCode(It.IsAny<ISet<VirtualRegister>>()), Times.Once);
}
```

### 統合テスト例

```csharp
[Fact]
public async Task EndToEnd_ExtendedSyntaxCompilation()
{
    // Arrange
    var services = new ServiceCollection();
    services.AddSingleton<ILexer, ExtendedLexer>();
    services.AddSingleton<IParser, ExtendedParser>();
    services.AddSingleton<IRegisterAllocator, RegisterAllocator>();
    services.AddSingleton<ICompilerService, CompilerService>();
    
    var provider = services.BuildServiceProvider();
    var compiler = provider.GetRequiredService<ICompilerService>();
    
    var source = @"
        LET %result = %a + %b
        STORE %result -> [0x10010000]
    ";
    
    // Act
    var result = await compiler.CompileAsync(source);
    
    // Assert
    Assert.True(result.Success);
    Assert.NotEmpty(result.Binary);
}
```

---

## まとめ

### アーキテクチャの特徴

1. **3層分離**: Presentation / Runtime / Compiler
2. **依存性逆転**: 上位→下位はインターフェース経由のみ
3. **疎結合**: レイヤー間はサービスインターフェースで通信
4. **密凝集**: 各クラス/パッケージは単一責務

### SOLID遵守のメリット

- ✅ **保守性**: 変更の影響範囲が限定的
- ✅ **拡張性**: 新機能追加が容易（既存コード変更不要）
- ✅ **テスト性**: モック注入でユニットテスト可能
- ✅ **再利用性**: コンポーネントの独立性が高い
- ✅ **理解性**: 各クラスの責務が明確

### 設計パターン活用のメリット

- 実証済みのソリューション
- チーム間での共通言語
- コードの意図が明確
