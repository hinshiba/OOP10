# MIPSアセンブリGUIランタイム兼デバッガー 要件定義

## 1. プロジェクト概要

### 1.1 目的
C#およびAvalonia UIを使用したMVVMアーキテクチャによる，教育・開発目的のMIPSアセンブリ実行環境とデバッガーの構築

### 1.2 技術スタック
- **言語**: C# 11.0以上
- **UIフレームワーク**: Avalonia UI 11.x
- **アーキテクチャパターン**: MVVM (Model-View-ViewModel)
- **ターゲットフレームワーク**: .NET 8.0

---

## 2. 機能要件

### 2.1 レジスタ割り付けを任せる拡張構文

#### 2.1.1 仮想レジスタ構文
- **記法**: `%v0`, `%v1`, ... `%vN` の形式で仮想レジスタを指定
- **自動割り付け**: 仮想レジスタを実際のMIPSレジスタ (`$t0`-`$t9`, `$s0`-`$s7`) に自動マッピング
- **生存期間解析**: 変数の使用範囲を解析し，レジスタの再利用を最適化
- **スピル処理**: レジスタ不足時は自動的にスタックへ退避/復帰

#### 2.1.2 高水準構文
```mips
add index 1 index
```

#### 2.1.3 制約
- 関数呼び出し規約 (caller-saved/callee-saved) を遵守
- `$a0`-`$a3` (引数レジスタ), `$v0`-`$v1` (戻り値レジスタ) は予約
- `$ra`, `$sp`, `$fp`, `$gp`, `$zero` は常に本来の用途で使用

#### 2.1.4 変換処理
- パース時に拡張構文を検出
- リニアスキャンでレジスタ割り付け
- 標準MIPSアセンブリへトランスパイル

---

### 2.2 MIPSランタイム

#### 2.2.1 サポート命令セット
**必須命令 (MIPS I準拠)**

| カテゴリ   | 命令                                                                                          |
| ---------- | --------------------------------------------------------------------------------------------- |
| 算術演算   | `add`, `addu`, `addi`, `addiu`, `sub`, `subu`, `mult`, `multu`, `div`, `divu`, `mfhi`, `mflo` |
| 論理演算   | `and`, `andi`, `or`, `ori`, `xor`, `xori`, `nor`, `sll`, `srl`, `sra`, `sllv`, `srlv`, `srav` |
| 比較・分岐 | `slt`, `slti`, `sltu`, `sltiu`, `beq`, `bne`, `blez`, `bgtz`, `bltz`, `bgez`                  |
| ジャンプ   | `j`, `jal`, `jr`, `jalr`                                                                      |
| メモリ操作 | `lw`, `lh`, `lhu`, `lb`, `lbu`, `sw`, `sh`, `sb`, `lui`                                       |
| システム   | `syscall`, `break`, `nop`                                                                     |

**擬似命令**
- `li`, `la`, `move`, `b`, `bnez`, `beqz` など

#### 2.2.2 メモリモデル
- **テキストセグメント**: `0x00400000` - `0x0FFFFFFF` (256MB，コード領域)
- **データセグメント**: `0x10000000` - `0x1FFFFFFF` (256MB，静的データ)
- **ヒープ**: `0x10040000` 開始 (動的メモリ，上位成長)
- **スタック**: `0x7FFFFFFC` 開始 (下位成長，8MB)

#### 2.2.3 システムコール (syscall)
| 番号 ($v0) | 機能                  | 引数                           |
| ---------- | --------------------- | ------------------------------ |
| 1          | print_int             | `$a0` = integer                |
| 4          | print_string          | `$a0` = string address         |
| 5          | read_int              | 戻り値: `$v0`                  |
| 8          | read_string           | `$a0` = buffer, `$a1` = length |
| 9          | sbrk (動的メモリ確保) | `$a0` = bytes                  |
| 10         | exit                  | -                              |
| 11         | print_char            | `$a0` = char                   |
| 12         | read_char             | 戻り値: `$v0`                  |

#### 2.2.4 例外処理
- **算術エラー**: ゼロ除算，オーバーフロー (設定で有効/無効)
- **メモリエラー**: 不正アドレスアクセス，アライメント違反
- **不正命令**: 未定義オペコード

---

### 2.3 ステップ実行

#### 2.3.1 実行モード
- **命令単位**: 1命令ずつ実行 (Step Into)
- **関数単位**: 関数呼び出しをスキップ (Step Over)
- **関数脱出**: 現在の関数から戻るまで実行 (Step Out)
- **連続実行**: ブレークポイントまで実行 (Continue)

#### 2.3.2 状態表示
リアルタイム更新:
- **レジスタビュー**: 全32本の汎用レジスタ + PC, HI, LO
- **メモリビュー**: 指定アドレス範囲の16進数/ASCII表示
- **スタックビュー**: スタックポインタ周辺の自動追跡
- **ディスアセンブリビュー**: 現在実行中の命令をハイライト
- **コールスタック**: 関数呼び出し階層

#### 2.3.3 実行速度制御
- 可変速度実行 (1命令/秒 〜 最大速度)
- 命令カウンタとサイクルカウンタの表示

---

### 2.4 ブレークポイント

#### 2.4.1 種類
- **行ブレークポイント**: 指定行で停止
- **アドレスブレークポイント**: 特定PCアドレスで停止
- **条件付きブレークポイント**: 式評価が真の時のみ停止
  ```
  例: $t0 == 10
      $a0 > 100
      mem[0x10010000] != 0
  ```
- **データブレークポイント (ウォッチポイント)**: 
  - 指定メモリアドレスへの書き込み検知
  - レジスタ値の変更検知

#### 2.4.2 管理機能
- ブレークポイント一覧表示
- 有効/無効の切り替え
- ヒットカウント (N回目の到達で停止)
- ログポイント (停止せず情報出力のみ)

---

### 2.5 タイムトラベルデバッグ

#### 2.5.1 スナップショット記録
**記録内容**:
- 全レジスタ状態 (32個の汎用レジスタ + PC, HI, LO)
- 変更されたメモリ範囲 (差分記録)
- 実行命令履歴
- syscallの入出力履歴

**記録タイミング**:
- 各命令実行後 (フルトレースモード)
- ブランチ/ジャンプ命令実行時のみ (軽量モード)
- ユーザー指定間隔 (N命令ごと)

#### 2.5.2 時間移動操作
- **後方再生**: 過去の任意の実行ポイントへ復元
- **前方再生**: 記録済みの未来へ進む (再実行なし)
- **リバースステップ**: 1命令前へ戻る
- **リバース Continue**: 前のブレークポイントまで遡る

#### 2.5.3 履歴表示
- **タイムラインビュー**: 時系列でのプログラムカウンタ遷移
- **変更差分ハイライト**: 前ステートからの変更箇所を色分け
- **コールスタック履歴**: 関数呼び出し/復帰の時系列

#### 2.5.4 最適化
- **メモリ効率化**: Copy-on-Write方式での差分管理
- **圧縮**: 連続する同一状態の省略
- **制限**: 最大記録数/メモリ使用量の設定可能
- **部分削除**: 古い履歴の選択的破棄

---

## 3. 非機能要件

### 3.1 パフォーマンス
- **実行速度**: 
  - 最適化モード: 1,000,000命令/秒以上
  - デバッグモード: 10,000命令/秒以上
- **起動時間**: 3秒以内
- **メモリ使用量**: 
  - 基本動作: 100MB以下
  - タイムトラベル有効時: 500MB以下 (10,000ステップ記録時)

### 3.2 ユーザビリティ
- **レスポンシブUI**: 操作後200ms以内に反応
- **キーボードショートカット**: 主要機能への高速アクセス
- **カスタマイズ可能なレイアウト**: ドッキング可能なパネル
- **テーマ**: ライト/ダークモード対応

### 3.3 移植性
- **クロスプラットフォーム**: Windows, macOS, Linux対応
- **ファイル互換性**: テキストベースのプロジェクトファイル (JSON/YAML)

### 3.4 拡張性
- **プラグインシステム**: カスタム命令セットの追加
- **API公開**: 外部ツールからの自動化サポート

---

## 4. アーキテクチャ設計指針

### 4.1 MVVMレイヤー

#### Model層
- `MipsProcessor`: 命令実行エンジン
- `RegisterFile`: レジスタ状態管理
- `Memory`: メモリ空間管理
- `Assembler`: アセンブル処理 (拡張構文含む)
- `RegisterAllocator`: レジスタ割り付けエンジン
- `DebugSession`: デバッグセッション管理
- `TimeTravel`: 履歴記録・復元

#### ViewModel層
- `MainViewModel`: アプリケーションルート
- `EditorViewModel`: コードエディタ制御
- `RegisterViewModel`: レジスタ表示制御
- `MemoryViewModel`: メモリビュー制御
- `DebugControlViewModel`: 実行制御UI
- `BreakpointViewModel`: ブレークポイント管理
- `TimeTravelViewModel`: 履歴ナビゲーション

#### View層 (Avalonia XAML)
- `MainWindow`: メインウィンドウ
- `EditorView`: コードエディタ (AvaloniaEdit使用)
- `RegisterView`: レジスタ一覧
- `MemoryView`: メモリダンプ
- `DebugToolbar`: 実行制御ボタン
- `BreakpointPanel`: ブレークポイント管理
- `TimelineView`: タイムトラベル制御

### 4.2 主要クラス設計パターン

#### 命令実行
- **Strategy Pattern**: 命令ごとの実行ロジック (`IInstruction` interface)
- **Command Pattern**: 実行/元に戻す操作

#### 状態管理
- **Memento Pattern**: タイムトラベル用スナップショット
- **Observer Pattern**: 状態変更通知 (ReactiveUI推奨)

#### レジスタ割り付け
- **Builder Pattern**: 干渉グラフ構築
- **Strategy Pattern**: 複数の割り付けアルゴリズム切り替え

---

## 5. データモデル

### 5.1 プロジェクトファイル構造
```json
{
  "version": "1.0",
  "source": "main.asm",
  "breakpoints": [
    {
      "line": 10,
      "condition": "$t0 == 5",
      "enabled": true
    }
  ],
  "watchpoints": [
    {
      "address": "0x10010000",
      "size": 4,
      "type": "write"
    }
  ],
  "settings": {
    "registerAllocation": true,
    "timeTravelEnabled": true,
    "maxHistorySteps": 10000
  }
}
```

### 5.2 スナップショット構造
```csharp
class ExecutionSnapshot
{
    public uint PC { get; set; }
    public uint[] Registers { get; set; } // 32要素
    public uint HI { get; set; }
    public uint LO { get; set; }
    public Dictionary<uint, byte[]> MemoryDeltas { get; set; }
    public long InstructionCount { get; set; }
    public DateTime Timestamp { get; set; }
}
```

---

## 6. ユースケース

### 6.1 基本フロー
1. ユーザーがMIPSアセンブリコードを記述/ロード
2. 拡張構文使用時，自動的にレジスタ割り付け実行
3. アセンブル成功後，メモリにロード
4. ブレークポイント設定
5. ステップ実行または連続実行
6. レジスタ/メモリ状態をリアルタイム監視
7. 必要に応じてタイムトラベルで過去状態を確認

### 6.2 拡張構文使用例
```mips
.data
    array: .word 1, 2, 3, 4, 5

.text
main:
    # 拡張構文を使用したループ
    la %base, array
    LET %i = 0
    LET %sum = 0
    
loop:
    # %i < 5
    LET %temp = LOAD [%base + %i * 4]
    LET %sum = %sum + %temp
    LET %i = %i + 1
    blt %i, 5, loop
    
    # 結果を表示
    move $a0, %sum    # 自動割り付けレジスタから標準レジスタへ
    li $v0, 1
    syscall
```

---

## 7. 制約事項・前提条件

### 7.1 制約
- メモリアドレス空間は32bit
- 浮動小数点演算は非対応 (将来拡張可能)
- マルチスレッド実行は非対応
- ハードウェア割り込みのシミュレーションなし

### 7.2 前提条件
- ユーザーはMIPSアセンブリの基礎知識を持つ
- .NET 8.0ランタイムがインストール済み

---

## 8. テスト要件

### 8.1 単体テスト
- 各命令の実行正確性
- レジスタ割り付けアルゴリズムの正確性
- メモリアクセスの境界条件

### 8.2 統合テスト
- エディタ→アセンブラ→実行エンジンのパイプライン
- デバッガ機能の協調動作

### 8.3 パフォーマンステスト
- 大規模プログラム (10,000行以上) の実行
- タイムトラベルの長時間実行時のメモリ使用量

### 8.4 ユーザビリティテスト
- 教育現場での試用
- 操作性のフィードバック収集

---

## 9. 開発マイルストーン

### Phase 1: コアランタイム (4週間)
- MIPSプロセッサエミュレータ
- 基本命令セット実装
- メモリ管理

### Phase 2: デバッガ基礎 (3週間)
- ステップ実行
- ブレークポイント
- 状態表示UI

### Phase 3: 拡張構文 (3週間)
- パーサー拡張
- レジスタ割り付けアルゴリズム
- トランスパイラ

### Phase 4: タイムトラベル (4週間)
- スナップショット機構
- 履歴UI
- 最適化

### Phase 5: 統合・テスト (2週間)
- 全機能統合
- バグ修正
- ドキュメント整備

---

## 10. 付録

### 10.1 参考資料
- MIPS32 Instruction Set Architecture (Release 6)
- "Computer Organization and Design" (Patterson & Hennessy)
- MARS (MIPS Assembler and Runtime Simulator) 仕様

### 10.2 用語集
- **レジスタ割り付け**: 仮想レジスタを物理レジスタへマッピングする処理
- **スピル**: レジスタ不足時にメモリへ退避すること
- **タイムトラベルデバッグ**: 実行履歴を遡って状態を確認できる機能
- **syscall**: システムコール，OSの機能を呼び出す命令
