# MIPSアセンブリGUIランタイム兼デバッガー 要件定義

## 1. プロジェクト概要

### 1.1 目的
C#およびAvalonia UIを使用したMVVMアーキテクチャによる，教育・開発目的のMIPSアセンブリ実行環境とデバッガーの構築

### 1.2 技術スタック
- **言語**: C# 14.0以上
- **UIフレームワーク**: Avalonia UI
- **アーキテクチャパターン**: MVVM (Model-View-ViewModel)
- **ターゲットフレームワーク**: .NET 10.0

---

## 2. 機能要件

### 2.1 ランタイムサービス

- アセンブラ
- メモリ
- プロセッサ
- システムコールハンドラ
で構成する．

#### 2.2.1 サポート命令セット
**必須命令 (MIPS I準拠)**

| カテゴリ   | 命令                                                                                          |
| ---------- | --------------------------------------------------------------------------------------------- |
| 算術演算   | `add`, `addu`, `addi`, `addiu`, `sub`, `subu`, `mult`, `multu`, `div`, `divu`, `mfhi`, `mflo` |
| 論理演算   | `and`, `andi`, `or`, `ori`, `xor`, `xori`, `nor`, `sll`, `srl`, `sra`, `sllv`, `srlv`, `srav` |
| 比較・分岐 | `slt`, `slti`, `sltu`, `sltiu`, `beq`, `bne`, `blez`, `bgtz`, `bltz`, `bgez`                  |
| ジャンプ   | `j`, `jal`, `jr`, `jalr`                                                                      |
| メモリ操作 | `lw`, `lh`, `lhu`, `lb`, `lbu`, `sw`, `sh`, `sb`, `lui`                                       |
| システム   | `syscall`, `break`, `nop`                                                                     |

**擬似命令**
- `li`, `la`, `move`, `b`, `bnez`, `beqz` など

#### 2.2.2 メモリモデル
- **テキストセグメント**: `0x00400000` - `0x0FFFFFFF` (256MB，コード領域)
- **データセグメント**: `0x10000000` - `0x1FFFFFFF` (256MB，静的データ)
- **ヒープ**: `0x10040000` 開始 (動的メモリ，上位成長)
- **スタック**: `0x7FFFFFFC` 開始 (下位成長，8MB)

#### 2.2.3 システムコール (syscall)
| 番号 ($v0) | 機能                  | 引数                           |
| ---------- | --------------------- | ------------------------------ |
| 1          | print_int             | `$a0` = integer                |
| 4          | print_string          | `$a0` = string address         |
| 5          | read_int              | 戻り値: `$v0`                  |
| 8          | read_string           | `$a0` = buffer, `$a1` = length |
| 9          | sbrk (動的メモリ確保) | `$a0` = bytes                  |
| 10         | exit                  | -                              |
| 11         | print_char            | `$a0` = char                   |
| 12         | read_char             | 戻り値: `$v0`                  |

#### 2.2.4 例外処理
- **算術エラー**: ゼロ除算，オーバーフロー (設定で有効/無効)
- **メモリエラー**: 不正アドレスアクセス，アライメント違反
- **不正命令**: 未定義オペコード

---

### 2.2 デバッグサービス

#### 2.2.1 実行モード
- **命令単位**: 1命令ずつ実行 (Step Into)
- **関数単位**: 関数呼び出しをスキップ (Step Over)
- **関数脱出**: 現在の関数から戻るまで実行 (Step Out)
- **連続実行**: ブレークポイントまで実行 (Continue)
- **リバースステップ**: 1命令前へ戻る
- **前方再生**: 記録済みの未来へ進む (再実行なし)

#### 2.2.2 状態表示
リアルタイム更新:
- **レジスタビュー**: 全32本の汎用レジスタ + PC, HI, LO
- **メモリビュー**: 指定アドレス範囲の16進数/ASCII表示
- **スタックビュー**: スタックポインタ周辺の自動追跡
- **ディスアセンブリビュー**: 現在実行中の命令をハイライト
- **コールスタック**: 関数呼び出し階層

#### 2.2.3 種類
- **行ブレークポイント**: 指定行で停止
- **データブレークポイント (ウォッチポイント)**: 
  - 指定メモリアドレスへの書き込み検知
  - レジスタ値の変更検知

#### 2.2.4 管理機能
- ブレークポイント一覧表示
- 有効/無効の切り替え

#### 2.2.5 スナップショット記録
**記録内容**:
- 全レジスタ状態 (32個の汎用レジスタ + PC, HI, LO)
- 変更されたメモリ範囲 (差分記録)
- 実行命令履歴
- syscallの入出力履歴

**記録タイミング**:
- 各命令実行後

### 2.3 レジスタ割り付けを任せる拡張構文 (Optional)

#### 2.3.1 仮想レジスタ構文
- **記法**: `%x0`, `%x1`, ... `%xN` の形式で仮想レジスタを指定
- **自動割り付け**: 仮想レジスタを実際のMIPSレジスタ (`$t0`-`$t9`, `$s0`-`$s7`) に自動マッピング
- **生存期間解析**: 変数の使用範囲を解析し，レジスタの再利用を最適化
- **スピル処理**: レジスタ不足時は自動的にスタックへ退避/復帰

#### 2.3.2 制約
- 関数呼び出し規約 (caller-saved/callee-saved) を遵守
- `$a0`-`$a3` (引数レジスタ), `$v0`-`$v1` (戻り値レジスタ) は予約
- `$ra`, `$sp`, `$fp`, `$gp`, `$zero` は常に本来の用途で使用

#### 2.3.3 変換処理
- パース時に拡張構文を検出
- リニアスキャンでレジスタ割り付け
- 標準MIPSアセンブリへトランスパイル

---

## 3. 非機能要件

### 3.1 パフォーマンス
- 特になし

### 3.2 ユーザビリティ
- **レスポンシブUI**: ある程度サクサク動くこと
- **キーボードショートカット**: 主要機能への高速アクセス

### 3.3 拡張性
- **API公開**: 外部ツールからの自動化サポート

---


## 4. 制約事項・前提条件

### 4.1 制約
- メモリアドレス空間は32bit
- 浮動小数点演算は非対応 (将来拡張可能)
- マルチスレッド実行は非対応
- ハードウェア割り込みのシミュレーションなし

